I'm still a little confused about using my computer's terminal versus my ide terminal.
It seems more effective to use the ide one, but I admit I am relatively new to the whole thing.
The term fork in the context of GitHub basically means copy

my aws ip addy
http://184.73.198.144/
command to remote shell:
ssh -i "C:\Users\becca\OneDrive\Documents\School\CS260\---" ubuntu@260dreams.click
Note also that I am unsure whether my computer actually has ubuntu at all. Not sure if I want to subscribe, either. 
-The class instruction mentioned nothing about it, which could either mean I don't need it, or they expect everyone to already have it.

Commands for the windows terminal:
pwd = Present working Directory
cd = change directory
ls = List files
-la = (will list in long format)
mkdir/rmdir=make/remove directory
rm/mv/cp=remove/move/copy files
find = find files
cat = output file contents
wc=wordcount
kill = kill running process
sudo = execute command as admin
ssh = secure shell
ctrl+c = kill current command
>/>> = redirect output to file. single overwrites, double appends
| = pipes output from left command into right command

http = hypertext transport protocol (non-secure)
https = secure version (should always be used/supported nowadays (in anything you build))
when using non-secure connections, anyone with access to the network traffic can capture all data sent in either direction (bad)
SOA = start of authority - a record that provides contact info about the owner of the domain name
the handshake exchanges web certificate which identifies domain name of server creating the secure connection.
the browser compares the certificate domain name to the one repped in the url and if they don't match or if the certificate is invalid, you get a warning display
Web Certificates are generated by a third party. the issuer is responsible for verifying the owner.
HTML = HyperText Markup Language was originally created as a publishing format for web pages, now reps either SPA or MPA
SPA = Single Page Application
MPA = Multi-page application - a group of hyperlinked pages

always include the <!doctype> brackets when coding an html
*it is common to name the main file index in htmls 
an html file is coded by <body>, which has three sections: header, main, and footer. Each section may contain other structural content
A hyperlink in HTML is represented with an anchor (a) element that has an attribute containing the address of the hyperlink reference (href). 
A hyperlink to BYU's home page looks like this: <a href="https://byu.edu">Go to the Y</a>

Since we now have JavaScript to supplement our htmls, we don't need to include a "form" element, though we can

Cascading Style Sheets (CSS)
CSS converts structure and content of html to a vibrant, responsive experience
concerned with defining rulesets or rules
rule is comprised of a Selector that selects elements to apply the rule to and Declarations that represent the Property to style  w the property value
the style element should appear in the Head element of the doc
elements inherit the rules applied to their parents
CSS defines everything as boxes
<div>s are automatically defined as boxes in html, too. Can of course be changed from CSS
CSS flex display (display: flex) is useful when you want your content to react to the window size/orientation.

Bootstrap CSS package is good to use for when JS is needed. Bootstrap is very common to use
to  include Bootstrap in your application using NPM you would run the following from your console: npm install bootstrap@5.2.3 (ver num may need to be updated from time to time)

JavaScript = most commonly used language
use keyword "let" or "const" (depending if you want it constant or able to change) to define variables (not "var")
objects can change type based on what you assign to them, they may not necessarily remain the way they were defined (will adapt)
JS supports the regular mathmatical operators (triple === for equality(or !== for not))
    at least for number vars. For strings, only + and ===
    double == is technically usable but can give unexpected results with the complex defining rules.
Can define a string with ', ", or `

Unicode is a thing that helps you support other languages

functions begin with keyword "function"
and, yes, you can declare functions from inside other functions
These two functions are the same:
    // standard function syntax
    a.sort(function (v1, v2) {
        return v1 - v2;
    });
    // arrow function syntax
    a.sort((v1, v2) => v1 - v2);
Return statements with arrow function:
    () => 3;
    // RETURNS: 3
    () => {
        3;
    };
    // RETURNS: undefined
    () => {
        return 3;
    };
    // RETURNS: 3

debounce functions are good for efficiency. They will restrict execution of a function to once per /time-slot/. The time will reset every time the debounce function is called

&nbsp = non-breaking space character. will add a space when typed

JavaScript Object Notation (JSON): can be converted to and from Javascript
A JS obj reps a collection of name-value pairs referred to as properties
JS Objects (not to be confused with your avg obj) can be created with the new operator/keyword
Object-literal syntax allows you to provide initial composition of obj
creating a class signifies intent to create a reusable component
Classes have an explicit constructor
properties and functions of classes can be made private with a '#' in front
    ->use the # every time you reference it, as well
extends can create an inheritance.
    class employee extends person {}
a parent's functions can be accessed using keyword 'super'
Regular Expressions are built in to JS
use a reg exp to find text in a string
create a reg exp using the class constructor or a reg exp literal
turn the last parameter into a rest parameter by leading it w ... this allows you to call the funtion with any number of parameters, which are all automatically combined into an array
handle exceptions with try/catch and throw syntax
remember you can also have a 'finally' block after a 'try' block that will always execute no matter whether an exception was thrown
restrict exceptions to exceptional situations, not things that are going to be happening often. Just debug your code, dude
fallbacks help handle exceptions and provide something to return even when an exception is thrown
destructuring != destructing
destructuring lets you pull items out of something like an array or object
^tricky syntax
Scope is the variables that are visible in the context of execution.
    Global- visible to all code
    Module- visible to all code running in a module
    Function- visible withing a function
    Block- visible within a block of code delimited by curly braces
Once again, don't use term var unless in a very particular situation... it ignores block scope
three diff contexts 'this' can refer to:
    Global- referenced from outside a function, context for runtime enviro
    Function- from inside a function, refers to obj that owns the function
    Object- from inside an object, refers to same obj
JS modules allow for partitioning and sharing of code
JS has module support for ES6. 
Node.js modules=CommonJS modules JS modules=ES modules
modules create a file-based scope for their code, so you must export objects from one file and import them into another
cannot access JS contained in a module that your nonmodule JS is executing in
from html. specify you are using an ES module
    <script type="module"></script>

DOM= Document Object Model, an object representation of HTML elements
property textContent sets the child text for an element

JS executes as a single thread-- ie there is only ever one piece of code executing at any given time
However, you can run the same program in parallel- asynchronously- with a Promise, which can be in any of three states: Pending, Fulfilled, and Rejected
Create a promise by calling the Promise object constructor and passing in an executor function
You can set the state to Fulfilled or Rejected with Resolve or Reject commands/methods
once a Promise has been resolved, handle it like unto an exception. Catch if the promise was rejected, Then is called if Promise==Fulfilled, and Finally is always called once the processing is completed. 
Observers are similar and also allow asynchronous processing

await keyword wraps execution of Promise. Blocks it until the state moves to Fulfilled (or throws an exception if the state moves to Rejected)
can only call Await at the top level of JavaScript, or in a function defined with keyword Async. This keyword transforms the functions so it returns a Promise to resolve whatever value was previously returned. ie, it turns any function into an asynchronous function
Using await when calling a function defined with async will return the result of the promise defined (or implicitly defined) within the function. Not using 'await' will return the whole promise object
a promise can be equated to a then/catch chain or try/catch block with an await in there

When debugging:
write a block of code, then step through and debug the block (before writing the next one)
console.log() functions output the state of the code as it executes. This can be an easy way to help debug
You can also debug in the browser console
Source tab (in browser debugger) shows the code. Can click to highlight a line which will then be a breakpoint. Just refresh the page and program will stop there.

keyword 'defer' will delay code until the end
chmod +x deploy.sh <-command to make a script executable
DNS = Domain Name System
You cannot use 'undefined' in JSON. Or single quotes.