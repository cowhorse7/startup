I'm still a little confused about using my computer's terminal versus my ide terminal.
It seems more effective to use the ide one, but I admit I am relatively new to the whole thing.
The term fork in the context of GitHub basically means copy

my aws ip addy
http://184.73.198.144/
command to remote shell:
ssh -i "C:\Users\becca\OneDrive\Documents\School\CS260\---" ubuntu@260dreams.click
Note also that I am unsure whether my computer actually has ubuntu at all. Not sure if I want to subscribe, either. 
-The class instruction mentioned nothing about it, which could either mean I don't need it, or they expect everyone to already have it.

Commands for the windows terminal:
pwd = Present working Directory
cd = change directory
ls = List files
-la = (will list in long format)
mkdir/rmdir=make/remove directory
rm/mv/cp=remove/move/copy files
find = find files
cat = output file contents
wc=wordcount
kill = kill running process
sudo = execute command as admin
ssh = secure shell
ctrl+c = kill current command
>/>> = redirect output to file. single overwrites, double appends
| = pipes output from left command into right command

http = hypertext transport protocol (non-secure)
https = secure version (should always be used/supported nowadays (in anything you build)) (web certificate necessary) (port 443)
when using non-secure connections, anyone with access to the network traffic can capture all data sent in either direction (bad)
SOA = start of authority - a record that provides contact info about the owner of the domain name
the handshake exchanges web certificate which identifies domain name of server creating the secure connection.
the browser compares the certificate domain name to the one repped in the url and if they don't match or if the certificate is invalid, you get a warning display
Web Certificates are generated by a third party. the issuer is responsible for verifying the owner.
HTML = HyperText Markup Language was originally created as a publishing format for web pages, now reps either SPA or MPA
SPA = Single Page Application
MPA = Multi-page application - a group of hyperlinked pages

always include the <!doctype> brackets when coding an html
*it is common to name the main file index in htmls 
an html file is coded by <body>, which has three sections: header, main, and footer. Each section may contain other structural content
A hyperlink in HTML is represented with an anchor (a) element that has an attribute containing the address of the hyperlink reference (href). 
A hyperlink to BYU's home page looks like this: <a href="https://byu.edu">Go to the Y</a>

Since we now have JavaScript to supplement our htmls, we don't need to include a "form" element, though we can

Cascading Style Sheets (CSS)
CSS converts structure and content of html to a vibrant, responsive experience
concerned with defining rulesets or rules
rule is comprised of a Selector that selects elements to apply the rule to and Declarations that represent the Property to style  w the property value
the style element should appear in the Head element of the doc
elements inherit the rules applied to their parents
CSS defines everything as boxes
<div>s are automatically defined as boxes in html, too. Can of course be changed from CSS
CSS flex display (display: flex) is useful when you want your content to react to the window size/orientation.

Bootstrap CSS package is good to use for when JS is needed. Bootstrap is very common to use
to  include Bootstrap in your application using NPM you would run the following from your console: npm install bootstrap@5.2.3 (ver num may need to be updated from time to time)

JavaScript = most commonly used language
use keyword "let" or "const" (depending if you want it constant or able to change) to define variables (not "var")
objects can change type based on what you assign to them, they may not necessarily remain the way they were defined (will adapt)
JS supports the regular mathmatical operators (triple === for equality(or !== for not))
    at least for number vars. For strings, only + and ===
    double == is technically usable but can give unexpected results with the complex defining rules.
Can define a string with ', ", or `

Unicode is a thing that helps you support other languages

functions begin with keyword "function"
and, yes, you can declare functions from inside other functions
These two functions are the same:
    // standard function syntax
    a.sort(function (v1, v2) {
        return v1 - v2;
    });
    // arrow function syntax
    a.sort((v1, v2) => v1 - v2);
Return statements with arrow function:
    () => 3;
    // RETURNS: 3
    () => {
        3;
    };
    // RETURNS: undefined
    () => {
        return 3;
    };
    // RETURNS: 3

debounce functions are good for efficiency. They will restrict execution of a function to once per /time-slot/. The time will reset every time the debounce function is called

&nbsp = non-breaking space character. will add a space when typed

JavaScript Object Notation (JSON): can be converted to and from Javascript (but does not require JS to be processed)
ex: let o = {number=1,value="carrot",features=['orange','root']};
A JS obj reps a collection of name-value pairs referred to as properties
JS Objects (not to be confused with your avg obj) can be created with the new operator/keyword
Object-literal syntax allows you to provide initial composition of obj
creating a class signifies intent to create a reusable component
can add new properties to a JS obj dynamically, or after defining it
Classes have an explicit constructor
properties and functions of classes can be made private with a '#' in front
    ->use the # every time you reference it, as well
extends can create an inheritance.
    class employee extends person {}
a parent's functions can be accessed using keyword 'super'
Regular Expressions are built in to JS
use a reg exp to find text in a string
create a reg exp using the class constructor or a reg exp literal
turn the last parameter into a rest parameter by leading it w ... this allows you to call the funtion with any number of parameters, which are all automatically combined into an array
handle exceptions with try/catch and throw syntax
remember you can also have a 'finally' block after a 'try' block that will always execute no matter whether an exception was thrown
restrict exceptions to exceptional situations, not things that are going to be happening often. Just debug your code, dude
fallbacks help handle exceptions and provide something to return even when an exception is thrown
destructuring != destructing
destructuring lets you pull items out of something like an array or object
^tricky syntax
Scope is the variables that are visible in the context of execution.
    Global- visible to all code
    Module- visible to all code running in a module
    Function- visible withing a function
    Block- visible within a block of code delimited by curly braces
Once again, don't use term var unless in a very particular situation... it ignores block scope
three diff contexts 'this' can refer to:
    Global- referenced from outside a function, context for runtime enviro
    Function- from inside a function, refers to obj that owns the function
    Object- from inside an object, refers to same obj
JS modules allow for partitioning and sharing of code
JS has module support for ES6. 
Node.js modules=CommonJS modules JS modules=ES modules
modules create a file-based scope for their code, so you must export objects from one file and import them into another
cannot access JS contained in a module that your nonmodule JS is executing in
from html. specify you are using an ES module
    <script type="module"></script>

DOM= Document Object Model, an object representation of HTML elements
^ a tree-structured rep of the html
property textContent sets the child text for an element
calling .textContent allows you to change the text in an element

JS executes as a single thread-- ie there is only ever one piece of code executing at any given time
However, you can run the same program in parallel- asynchronously- with a Promise, which can be in any of three states: Pending, Fulfilled, and Rejected
Create a promise by calling the Promise object constructor and passing in an executor function
You can set the state to Fulfilled or Rejected with Resolve or Reject commands/methods
once a Promise has been resolved, handle it like unto an exception. Catch if the promise was rejected, Then is called if Promise==Fulfilled, and Finally is always called once the processing is completed. 
Observers are similar and also allow asynchronous processing

await keyword wraps execution of Promise. Blocks it until the state moves to Fulfilled (or throws an exception if the state moves to Rejected)
can only call Await at the top level of JavaScript, or in a function defined with keyword Async. This keyword transforms the functions so it returns a Promise to resolve whatever value was previously returned. ie, it turns any function into an asynchronous function
Using await when calling a function defined with async will return the result of the promise defined (or implicitly defined) within the function. Not using 'await' will return the whole promise object
a promise can be equated to a then/catch chain or try/catch block with an await in there

When debugging:
write a block of code, then step through and debug the block (before writing the next one)
console.log() functions output the state of the code as it executes. This can be an easy way to help debug
You can also debug in the browser console
Source tab (in browser debugger) shows the code. Can click to highlight a line which will then be a breakpoint. Just refresh the page and program will stop there.

keyword 'defer' will delay code until the end
chmod +x deploy.sh <-command to make a script executable
chmod changes a file's mode bits to control the access rights to a file
DNS = Domain Name System
You cannot use 'undefined' in JSON. Or single quotes.
TLD = Top level domain (the final section of a domain name, such as click, com, org, etc)
a root domain is a website name, like cs260.click, and a subdomain is a sub of that, like simon.cs260.click

the internet is an interconnected web of wires (and wireless wires) throughout the world
When one device wants to talk to another, it needs an IP address. Users often prefer symbolic names over the number address, called a domain name. You can convert a domain name  by looking it up in the DNS and using the command dig
devices and websites both have IP addresses
traceroute command will allow you to see route of requests from requester to destination
traceroute may not always show the exact same route
ISP = Internet Service Provider
TCP = Transmission Control Protocol
IP= Internet Protocol
TCP/IP Layers: Application (functionality), Transport (moving), Internet (establishing connections), and Link (physical connections)

a web server is a computing device that is hosting a seb service and knows how to accept incoming connections
in early days, this was a massive, complex, expensive software program
now, most programming languages include libraries that provide the ability to make connections and serve http
it is common to find multiple services running on the same device. every network device allows for seperate network connections through unique port numbers. Each service starts on a diff port
This can be confusing, so we may introduce a service gateway that begins on the https port 443 and can redirect us to other services.
*Caddy is our current gateway
web services providing a single function are microservices. These can be managed independently from a larger system. They can also make stateless copies based on user demand.
In serverless functionality, the server is removed from the architecture; you write a function speaking HTTP that is loaded through the gateway mapping a request to that function.

the owner of a root domain can create any number of subdomains off the root domain. each sub may use a diff ip addy.
use command whois to find information on a particular domain name
address (A) and Canonical name (CNAME) records map domain names to ip addresses. A's straight map it together; cname maps one domain name to another domain name, which acts as an alias (such as mapping byu.com to byu.edu)
Authoritative Name Servers assiciate domain names with ip addys
Time to Live (TIL) is a setting for domain records. 

the html/css/js/image files that run on the browser are the Frontend of your application
Currently, my app is loaded from my web server and runs on the user's browser
frontend uses https protocol to request the app files
can make requests to anywhere from frontend js (often with a fetch function)
*to build a full stack web app, create your own web service
the functionality provided by your web service reps the Backend of your app
endpoints are the functions provided by a web service. aka APIs
access endpoints from frontend js with the fetch function
backend provides static files making up the frontend as well as service endpoints called by the frontend
Fetch function can be used to request data either from the backend web service (provided files) or from other web services

URL = uniform resource locator
^location of a web resource
there are many parts to a url, and most of them are optional
<scheme>://<domain name>:<port>/<path>?<parameters>#<anchor>
this is the format of a url. the only required parts are the scheme and domain name
scheme: protocol required to ask for the resource. (usually https)
domain name: name that owns the resource rep'ed by the url
Port: specifies numbered network port used to connect to domain server (default 443 for https)
Path: path to resource on domain
Parameters: rep a list of key-value pairs, usually provides additional qualifiers on resource rep'ed by the path. sometimes called query str
Anchor: reps a sub-location in the resource. sometimes called fragment or hash ID
URN = Uniform Resource Name
^ a unique resource name not specifying location info
URI = Uniform Resource Identifier
^ a gen identifier that could refer either to a url or urn (usually a url, which you should generally be using anyway)

When connecting a device to the internet, you need both an IP address and a numbered Port.
port numbers allow a single device to support multiple protocols (ie http, https, ssh, etc) and diff types of services (search, authenticate,...)
HTTPS port = 443
HTTP port = 80
SSH port = 22
IANA = internet governing body
ports 0-1023 are standard protocols and should be avoided if not being used the standard way
ports 1024-49151 rep ports assigned to requesting entities and are commonly used by internal device services
ports 49152-65535 are used to create dynamic connections to a device
when (my) caddy receives a port 80 request, it auto-redirects to port 443
on your web server, you can have as many services running as desired, but each must use a diff port to communicate